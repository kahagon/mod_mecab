/* 
**  mod_mecab.c -- Apache sample mecab module
**  [Autogenerated via ``apxs -n mecab -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_mecab.c
**
**  Then activate it in Apache's apache2.conf file for instance
**  for the URL /mecab in as follows:
**
**    #   apache2.conf
**    LoadModule mecab_module modules/mod_mecab.so
**    <Location /mecab>
**    SetHandler mecab
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /mecab and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/mecab 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_mecab.c
*/ 

#include <mecab.h>

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"

#include "linkhash.h"
#include "json_tokener.h"
#include "json_object.h"

#include "apr_pools.h"
#include "apr_strings.h"
#include "apr_tables.h"

#include "apreq_param.h"

#define MECAB_QUERY_NUMBERS 16
#define MECAB_TARGET_QUERY_NAME_DIRECTIVE "MecabTargetQueryName"
#define MECAB_TARGET_QUERY_NAME_DEFAULT "q"
#define MECAB_JSON_ENV_NAME_DIRECTIVE "MecabJsonEnvName"
#define MECAB_JSON_ENV_NAME_DEFAULT "MECAB_JSON"

#define mecab_error_handling_register_json_env(r, conf, message) \
        { \
            json_object *json_result = json_object_new_object(); \
            json_object_object_add(json_result, "error", json_object_new_boolean(TRUE)); \
            json_object_object_add(json_result, "error_message", json_object_new_string(message)); \
            apr_table_set(r->subprocess_env, conf->json_env_name_directive, json_object_to_json_string(json_result)); \
            json_object_put(json_result); \
        }

typedef struct mecab_config_t {
    char *target_query_name_directive;
    char *json_env_name_directive;
} mecab_config_t;

module AP_MODULE_DECLARE_DATA mecab_module;

static const char *mecab_init_directive_target_query_name(cmd_parms *cmd, void *mconfig, char *word) {
    mecab_config_t *conf = (mecab_config_t *)ap_get_module_config(cmd->server->module_config, &mecab_module);
    conf->target_query_name_directive = apr_pstrdup(cmd->pool, word);
    return NULL;
}
static const char *mecab_init_directive_json_env_name(cmd_parms *cmd, void *mconfig, char *word) {
    mecab_config_t *conf = (mecab_config_t *)ap_get_module_config(cmd->server->module_config, &mecab_module);
    conf->json_env_name_directive = apr_pstrdup(cmd->pool, word);
    return NULL;
}

static void mecab_register_result_to_subprocess_env(request_rec *r) {
    mecab_config_t *config = ap_get_module_config(r->server->module_config, &mecab_module);
    
    
    if (r->args == NULL) {
        mecab_error_handling_register_json_env(r, config, "query string is null. should send queries to parse.");
        return;
    }
    
    apr_pool_t *pool = r->pool;
    apr_table_t *table = apr_table_make(pool, MECAB_QUERY_NUMBERS);

    apr_status_t statcode = apreq_parse_query_string(pool, table, r->args);
    
    if (statcode != APR_SUCCESS) {
        apr_size_t bufsize = 512;
        char *buf = (char *)apr_pcalloc(r->pool,bufsize);
        apr_strerror(statcode, buf, bufsize);
        mecab_error_handling_register_json_env(r, config, buf);
        return;
    }
    if (apr_is_empty_table(table)) {
        mecab_error_handling_register_json_env(r, config, "query string is empty. should send queries to parse.");
        return;
    }
    
    const char *target_string = apr_table_get(table, config->target_query_name_directive);
    
    if (target_string == NULL) {
        mecab_error_handling_register_json_env(r, config, "missing query string to parse.");
        return;
    }
    
    json_object *json_result = json_object_new_object();
    json_object_object_add(json_result, "input", json_object_new_string(target_string));
    json_object *json_nodes = json_object_new_array();
    
    mecab_t *mecab = mecab_new(0, NULL);
    mecab_node_t *node = mecab_sparse_tonode(mecab, target_string);
    for (; node; node = node->next) {
        if (node->stat != MECAB_NOR_NODE && node->stat != MECAB_UNK_NODE) 
            continue;
        
        json_object *json_node = json_object_new_object();
        json_object_object_add(json_node, "surface", json_object_new_string(apr_pstrndup(pool, node->surface, node->length)));
        json_object_object_add(json_node, "feature", json_object_new_string(node->feature));
        json_object_object_add(json_node, "id", json_object_new_int(node->id));
        json_object_object_add(json_node, "length", json_object_new_int(node->length));
        json_object_object_add(json_node, "rlength", json_object_new_int(node->rlength));
        json_object_object_add(json_node, "rcAttr", json_object_new_int(node->rcAttr));
        json_object_object_add(json_node, "lcAttr", json_object_new_int(node->lcAttr));
        json_object_object_add(json_node, "posid", json_object_new_int(node->posid));
        json_object_object_add(json_node, "char_type", json_object_new_int(node->char_type));
        json_object_object_add(json_node, "stat", json_object_new_int(node->stat));
        json_object_object_add(json_node, "isbest", json_object_new_int(node->isbest));
        json_object_object_add(json_node, "sentence_length", json_object_new_int(node->sentence_length));
        json_object_object_add(json_node, "alpha", json_object_new_double(node->alpha));
        json_object_object_add(json_node, "beta", json_object_new_double(node->beta));
        json_object_object_add(json_node, "prob", json_object_new_double(node->prob));
        json_object_object_add(json_node, "wcost", json_object_new_int(node->wcost));
        json_object_object_add(json_node, "cost", json_object_new_double(node->cost));
        json_object_array_add(json_nodes, json_node);
    }
    json_object_object_add(json_result, "nodes", json_nodes);
    json_object_object_add(json_result, "error", json_object_new_boolean(FALSE));
    json_object_object_add(json_result, "error_message", json_object_new_string(""));

    apr_table_set(
            r->subprocess_env, 
            config->json_env_name_directive, 
            json_object_to_json_string(json_result));
    
    json_object_put(json_result);
    return;
}

/* The sample content handler */
static int mecab_handler(request_rec *r)
{
    if (strcmp(r->handler, "mecab")) {
        return DECLINED;
    }
    r->content_type = "text/javascript; charset=UTF-8";

    if (r->header_only)
        return OK;

    mecab_config_t *config = (mecab_config_t *)ap_get_module_config(r->server->module_config, &mecab_module);
    
    ap_rputs(apr_table_get(r->subprocess_env, config->json_env_name_directive), r);
    
    return OK;
}

static int mecab_quick_handler(request_rec *r, int lookup) {
    //mecab_config_t *conf = ap_get_module_config(r->server->module_config, &mecab_module);
    mecab_register_result_to_subprocess_env(r);
    return DECLINED;
}


static const command_rec cmds[] = {
    AP_INIT_TAKE1(
            MECAB_TARGET_QUERY_NAME_DIRECTIVE, 
            mecab_init_directive_target_query_name, 
            NULL, 
            RSRC_CONF | ACCESS_CONF, 
            "specify parameter name of target query string which will parsed by MeCab."),
    AP_INIT_TAKE1(
            MECAB_JSON_ENV_NAME_DIRECTIVE, 
            mecab_init_directive_json_env_name, 
            NULL, 
            RSRC_CONF | ACCESS_CONF, 
            "specify environment variable name of MeCab parsing result."),
    {NULL}
};

static void *create_config(apr_pool_t *pool, server_rec *server) {
    mecab_config_t *conf = (mecab_config_t *)apr_pcalloc(pool, sizeof(*conf));
    conf->target_query_name_directive = MECAB_TARGET_QUERY_NAME_DEFAULT;
    conf->json_env_name_directive = MECAB_JSON_ENV_NAME_DEFAULT;
    return conf;
}

static void mecab_register_hooks(apr_pool_t *p)
{
    ap_hook_quick_handler(mecab_quick_handler, NULL, NULL, APR_HOOK_FIRST);
    ap_hook_handler(mecab_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA mecab_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    create_config,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    cmds,                  /* table of config file commands       */
    mecab_register_hooks  /* register hooks                      */
};

